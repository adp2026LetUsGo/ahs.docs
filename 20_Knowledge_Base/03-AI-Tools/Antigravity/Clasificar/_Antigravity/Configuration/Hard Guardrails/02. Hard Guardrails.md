Dynamic Code Generation

This is a sharp observation. There is often a misunderstanding about what "code generation" means in the context of AI versus the context of the .NET runtime.

To address your concern: **Google Antigravity** itself does not cause Native AOT problems by existing; however, the **code it writes** can easily break your AOT build if the AI isn't "AOT-aware."

---

## üîç The "Dynamic" Distinction

The term "Dynamic Code Generation" has two meanings here, and only one is a problem for Native AOT:

1. **AI Source Generation (Safe):** Antigravity uses Gemini 3 to write `.cs` files. This is **design-time** generation. Since this code is written _before_ you compile, the Native AOT compiler can see it, analyze it, and turn it into machine code. This is perfectly fine.
    
2. **Runtime Dynamic Code (The Problem):** This refers to C# code that uses `System.Reflection.Emit`, `dynamic` types, or certain types of Reflection to create logic while the app is already running. **Native AOT forbids this** because there is no Just-In-Time (JIT) compiler to handle it at runtime.
    

---

## ‚ö†Ô∏è The Risk: AI "Hallucinating" Reflection

AI agents (like those in Antigravity or Cursor) are trained on millions of lines of legacy C# code that rely heavily on Reflection. If you ask an agent to "Create a JSON serializer," it might write code using `System.Reflection`, which will cause your Native AOT app to crash or fail to build.

### How to protect your .NET 10 project in Antigravity:

To ensure your Antigravity agents generate code that works with Native AOT, you must set up **Hard Guardrails**.

### 1. Project-Level Enforcement

In your `.csproj` (within your `.slnx` solution), you must be explicit. This forces the IDE's internal analyzers to flag the AI's mistakes immediately.

XML

```
<PropertyGroup>
  <TargetFramework>net10.0</TargetFramework>
  <PublishAot>true</PublishAot>
  <EnableAotAnalyzer>true</EnableAotAnalyzer>
  <EnableTrimAnalyzer>true</EnableTrimAnalyzer>
  <IllinkTreatWarningsAsErrors>true</IllinkTreatWarningsAsErrors>
</PropertyGroup>
```

### 2. Antigravity Agent "System Prompt"

Since Antigravity is an agentic IDE, you can give it specific instructions. You should add a rule to your project‚Äôs `.cursorrules` or the equivalent Antigravity configuration file:

> **Agent Instruction:** "This project targets Native AOT in .NET 10. You are strictly forbidden from using `System.Reflection`, `dynamic`, or any API marked with `[RequiresDynamicCode]`. Always prefer **Source Generators** (e.g., `JsonSourceGenerationOptions`) over reflection-based alternatives."

### 3. Replace Legacy Patterns

If the AI tries to use an old pattern, guide it toward the .NET 10 AOT-friendly version:

|**Avoid (AI often does this)**|**Use Instead (AOT Friendly)**|
|---|---|
|`JsonSerializer.Deserialize<T>(...)`|`JsonSerializer.Deserialize(..., MyContext.Default.T)`|
|`Activator.CreateInstance(type)`|Dependency Injection with static registration|
|`dynamic myObj = ...`|Strong types or `interface`|

---

## ‚úÖ Summary

Antigravity is a "source generator" in the human sense‚Äîit writes text. As long as the **text** it writes follows .NET 10 AOT rules, you won't have issues. By using the **Roslyn Analyzers** we discussed, you turn the "trial and error" process into a real-time correction loop where Gemini 3 fixes its own AOT-incompatible code before you even try to publish.

**Would you like me to show you how to set up a Source Generated JSON Context so you can instruct your Antigravity agent to use it?**