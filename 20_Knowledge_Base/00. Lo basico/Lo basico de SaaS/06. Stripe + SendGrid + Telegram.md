
Â¡Hecho, Armando! He **procedido** y ahora tienes una versiÃ³n del scaffold con **integraciones listas para conectar**:

- **Alertas por Email (SendGrid)** y **Telegram** ya cableadas (vÃ­a `HttpClient`, sin paquetes externos).
- **Webhook de Stripe** (endpoint listo; verificaciÃ³n de firma pendiente de Stripe.NET).
- **Pipelines** de GitHub Actions: `ci` (build & test) y `deploy-azure` (con _publish profiles_).
- README actualizado con **secrets** y **pasos de EF Core**.
- Mantengo tu enfoque **Clean Architecture**, **JWT**, **multitenancy por `TenantId`** y **Minimal APIs**.

---

## â¬‡ï¸ Descarga

**ShopWatch_v2.zip** â€” (scaffold + integraciones de Email/Telegram/Stripe + CI/CD)  
[ShopWatch_v2.zip](blob:https://www.microsoft365.com/6b9e1300-5d45-4ce1-b1e0-2c7a9de5e3e0)

> Esta versiÃ³n reemplaza la anterior y ya incluye las nuevas piezas.

---

## QuÃ© aÃ±adÃ­ exactamente

### 1) Integraciones de alertas

- **SendGrid** (`IEmailSender` â†’ `SendGridEmailSender`): envÃ­a HTML vÃ­a `https://api.sendgrid.com/v3/mail/send`.
- **Telegram** (`ITelegramSender` â†’ `TelegramSender`): envÃ­a mensajes a `sendMessage`.
- **Alert routing** (`AlertService`): usa un formato simple de canal:
    - `email:owner@example.com`
    - `telegram:123456789` (chat id)

ðŸ‘‰ Configura en `appsettings.Development.json`:

"SendGrid": { "ApiKey": "REPLACE_WITH_SENDGRID_API_KEY" },

"Telegram": { "BotToken": "REPLACE_WITH_TELEGRAM_BOT_TOKEN" }

### 2) Billing (Stripe)

- Endpoint **`POST /billing/webhook/stripe`** (Minimal API).
- Servicio `BillingService` con TODO para **verificar firma** usando `Stripe:SigningSecret`.

ðŸ‘‰ AÃ±ade al `appsettings.Development.json`:

"Stripe": { "SigningSecret": "REPLACE_WITH_STRIPE_SIGNING_SECRET" }

> _En producciÃ³n_, instala **Stripe.NET** y verifica la firma del header **`Stripe-Signature`** antes de procesar el evento.

### 3) Seguridad y auth

- `POST /auth/dev-token` (solo dev) para obtener un JWT rÃ¡pido.
- Usa `Authorization: Bearer <token>` para acceder a `/monitors`.

### 4) Worker de monitoreo (Scheduler)

- Ejecuta checks HTTP (`GET/HEAD` + `ExpectKeyword` opcional), persiste resultados y evalÃºa incidentes con **`CheckEvaluator`** (2 fallos consecutivos por defecto).

### 5) CI/CD

- **`.github/workflows/ci.yml`**: build & test con .NET 8.
- **`.github/workflows/deploy-azure.yml`**: publica Web y Worker y despliega vÃ­a `azure/webapps-deploy@v2`.
    - Define secretos:
        - `AZURE_PUBLISH_PROFILE_WEB`
        - `AZURE_WEBAPP_NAME_WEB`
        - `AZURE_PUBLISH_PROFILE_WORKER`
        - `AZURE_WEBAPP_NAME_WORKER`

---

## Pasos para correrlo ahora

1. **Crea la soluciÃ³n**:

./build/create-solution.ps1

2. **Configura DB & JWT** en `src/ShopWatch.Web/appsettings.Development.json`:

- `ConnectionStrings:Default` (SQL Server local o Azure SQL).
- `Jwt:Key` (cualquiera en dev).

3. **Migraciones EF Core**:

cd src/ShopWatch.Web

dotnet tool install --global dotnet-ef

dotnet ef migrations add InitialCreate -p ../ShopWatch.Infrastructure -s ./ -c ShopWatch.Infrastructure.ShopWatchDbContext

dotnet ef database update -s ./ -p ../ShopWatch.Infrastructure -c ShopWatch.Infrastructure.ShopWatchDbContext

4. **Arranca**:

dotnet run --project src/ShopWatch.WebÂ Â Â Â Â Â Â  # API + Swagger

dotnet run --project src/ShopWatch.WorkerÂ Â Â Â  # Scheduler

5. **JWT de desarrollo**:

POST [http://localhost:5000/auth/dev-token?tenantId=11111111-1111-1111-1111-111111111111&amp;email=me@example.com](http://localhost:5000/auth/dev-token?tenantId=11111111-1111-1111-1111-111111111111&amp;email=me@example.com)

Usa el `token` devuelto para:

- `GET /monitors`
- `POST /monitors` (crea monitor con `Url`, `Method`, `ExpectKeyword?`, `IntervalSec`, `TimeoutMs`)

6. **Status pÃºblica (stub)**:

- `GET /status/{slug}`

7. **Webhook Stripe (listo para conectar)**:

- `POST /billing/webhook/stripe` (firmas a verificar en `BillingService`).

---

## Siguientes mejoras (puedo hacerlo en el siguiente paso)

1. **VerificaciÃ³n de Stripe**
    
    - AÃ±adir paquete **Stripe.NET**, verificar firma con `Stripe:SigningSecret`, parsear `invoice.paid`, `customer.subscription.updated`, bloquear/activar features segÃºn `plan/status`.
2. **Persistencia de Incidentes**
    
    - Completar `IncidentService` para abrir/cerrar incidentes y notificar con `AlertService`.
3. **Alert policies**
    
    - Configurable por monitor (N fallos, backoff, ventana de supresiÃ³n).
    - Doble confirmaciÃ³n (re-check a 30s) para bajar falsos positivos.
4. **Status Page**
    
    - Slug por tenant, logo (Pro+), uptime 24h/7d, timeline con incidentes.
5. **Observabilidad**
    
    - App Insights, logging estructurado (request/dep), mÃ©tricas del worker.
6. **Endurecimiento**
    
    - Rate limiting, CORS, validaciones de entrada y `GlobalQueryFilter` por `TenantId`.

---

## Â¿QuÃ© quieres que integre ahora mismo?

Puedo **continuar** con una de estas rutas:

- **A. Stripe listo para producciÃ³n** (firma + eventos + estado de suscripciÃ³n).
- **B. Alertas completas** (SendGrid + Telegram con plantillas, reintentos, supresiÃ³n).
- **C. Status Page** (UI pÃºblica v1 con uptime + incidentes).
- **D. Pipeline Azure completo** (variables, _app settings_ por slot, health checks).

Dime **A/B/C/D** (o el orden de prioridad) y **procedo**.