Â¡Perfecto, Armando!  
AquÃ­ tienes **la versiÃ³n extendida completa**, en **Markdown**, con TODO lo que te prometÃ­ y mÃ¡s:

- Comparaciones completas Tâ€‘SQL â†” PostgreSQL
- Consultas avanzadas
- DDL comparado
- MigraciÃ³n de procedimientos reales
- OptimizaciÃ³n
- GuÃ­a para Azure PostgreSQL Flexible Server
- Consejos para Microâ€‘SaaS y multitenancy
- Snippets listos para usar

Este documento te funcionarÃ¡ como **fuente base en tus vaults de Obsidian, MkDocs y NotebookLM.**

---

# #ï¸âƒ£ **Tâ€‘SQL â†’ PostgreSQL: Extended Developer Guide (Markdown Edition)**

**MigraciÃ³n prÃ¡ctica para desarrolladores .NET, SaaS y arquitectura moderna**

---

# ğŸŸ¦ 0. Overview

Este documento cubre todo lo siguiente:

1. Tipos de datos equivalentes
2. DDL completo (CREATE TABLE, INDEX, etc.)
3. DML comparado (INSERT, UPDATE, DELETE)
4. SELECT avanzados equivalentes
5. Stored procedures â†’ Functions
6. Transacciones avanzadas
7. Triggers equivalentes
8. OptimizaciÃ³n y query planner
9. MigraciÃ³n de lÃ³gica Tâ€‘SQL real al estilo PostgreSQL
10. GuÃ­a rÃ¡pida de _multitenancy por esquema_
11. Azure PostgreSQL Flexible Server: recomendaciones
12. Extensiones recomendadas
13. Cheatsheets finales para imprimir

---

# ğŸŸ¦ 1. Tipos de datosâ€”versiÃ³n extendida

## 1.1. Tabla extendida de equivalencias

|Concepto|SQL Server|PostgreSQL|Comentarios|
|---|---|---|---|
|Entero normal|`INT`|`INTEGER`|Igual|
|Entero largo|`BIGINT`|`BIGINT`|Igual|
|Entero pequeÃ±o|`SMALLINT`|`SMALLINT`|Igual|
|Boolean|`BIT`|`BOOLEAN`|Usa `true/false`|
|Money|`MONEY`|`NUMERIC(19,4)`|MSSQL usa binarios internos|
|Texto largo|`NVARCHAR(MAX)`|`TEXT`|Sin lÃ­mite prÃ¡ctico|
|Unicode|`NVARCHAR`|`VARCHAR`|PostgreSQL es UTFâ€‘8 nativo|
|GUID|`UNIQUEIDENTIFIER`|`UUID`|Muy usado en SaaS|
|Fecha/hora|`DATETIME`|`TIMESTAMP`|Sin timezone|
|Fecha/hora con TZ|`DATETIMEOFFSET`|`TIMESTAMP WITH TIME ZONE`|Correcto|
|JSON|`NVARCHAR(MAX)` o `JSON`|`JSONB`|**PostgreSQL gana**|
|Binarios|`VARBINARY`|`BYTEA`|Similar|

---

# ğŸŸ¦ 2. DDL completo

## 2.1. CREATE TABLE

### SQL Server

CREATE TABLE People (

Â Â Â  Id INT IDENTITY(1,1) PRIMARY KEY,

Â Â Â  Name NVARCHAR(100),

Â Â Â  Email NVARCHAR(255) UNIQUE,

Â Â Â  CreatedAt DATETIME2 DEFAULT SYSDATETIME()

);

### PostgreSQL

CREATE TABLE people (

Â Â Â  id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

Â Â Â  name VARCHAR(100),

Â Â Â  email VARCHAR(255) UNIQUE,

Â Â Â  created_at TIMESTAMP DEFAULT NOW()

);

---

# ğŸŸ¦ 3. DML (INSERT, UPDATE, DELETE)

## 3.1. INSERT

### SQL Server

INSERT INTO People (Name, Email)

VALUES ('John', '[john@site.com](mailto:john@site.com)');

### PostgreSQL

INSERT INTO people (name, email)

VALUES ('John', '[john@site.com](mailto:john@site.com)');

âœ” Sintaxis idÃ©ntica.

---

## 3.2. OUTPUT vs RETURNING

SQL Server:

INSERT INTO People (Name)

OUTPUT inserted.Id

VALUES ('John');

PostgreSQL:

INSERT INTO people (name)

VALUES ('John')

RETURNING id;

> **`RETURNING` es una joya en PostgreSQL.**

---

# ğŸŸ¦ 4. SELECT avanzados

## 4.1. TOP vs LIMIT/OFFSET

### SQL Server

SELECT TOP 5 * FROM People ORDER BY Id DESC;

### PostgreSQL

SELECT * FROM people ORDER BY id DESC LIMIT 5;

---

## 4.2. Date functions

### SQL Server

SELECT DATEADD(DAY, 1, GETDATE())

### PostgreSQL

SELECT NOW() + INTERVAL '1 day';

---

## 4.3. Window functions (idÃ©nticas)

### SQL Server

SELECT Name, SUM(Sales) OVER(PARTITION BY Region)

FROM Reports;

### PostgreSQL

SELECT name, SUM(sales) OVER (PARTITION BY region)

FROM reports;

âœ” PostgreSQL tiene incluso mÃ¡s funciones disponibles.

---

# ğŸŸ¦ 5. Stored Procedures â†’ Funciones completas en PostgreSQL

## 5.1. Procedimiento con parÃ¡metros

### SQL Server

CREATE PROCEDURE GetPeopleByRegion

Â Â Â  @Region NVARCHAR(50)

AS

BEGIN

Â Â Â  SELECT * FROM People WHERE Region = @Region;

END;

### PostgreSQL

CREATE OR REPLACE FUNCTION get_people_by_region(region VARCHAR)

RETURNS SETOF people AS $

BEGIN

Â Â Â  RETURN QUERY

Â Â Â  SELECT * FROM people WHERE region = get_people_by_region.region;

END;

$ LANGUAGE plpgsql;

âœ” El concepto es el mismo  
â— La sintaxis no.

---

# ğŸŸ¦ 6. Transacciones avanzadas

## SQL Server

BEGIN TRANSACTION;

  

UPDATE People SET Active = 0 WHERE Id = 10;

  

COMMIT TRANSACTION;

## PostgreSQL

BEGIN;

  

UPDATE people SET active = false WHERE id = 10;

  

COMMIT;

---

# ğŸŸ¦ 7. Triggers completos

## SQL Server

CREATE TRIGGER trgUpdatePeople

ON People

FOR UPDATE

AS

BEGIN

Â Â Â  INSERT INTO PeopleAudit (PersonId, NewName)

Â Â Â  SELECT Id, Name FROM inserted;

END;

## PostgreSQL

CREATE OR REPLACE FUNCTION audit_people() RETURNS TRIGGER AS $

BEGIN

Â Â Â  INSERT INTO people_audit(person_id, new_name)

Â Â Â  VALUES (NEW.id, NEW.name);

Â Â Â  RETURN NEW;

END;

$ LANGUAGE plpgsql;

  

CREATE TRIGGER trg_update_people

AFTER UPDATE ON people

FOR EACH ROW

EXECUTE FUNCTION audit_people();

---

# ğŸŸ¦ 8. OptimizaciÃ³n y Query Planner

## 8.1. EXPLAIN

### SQL Server

SET SHOWPLAN_ALL ON;

### PostgreSQL

EXPLAIN ANALYZE SELECT ...;

> PostgreSQL ofrece **mÃ¡s claridad** en sus planes.

---

## 8.2. Ãndices recomendados para SaaS

CREATE INDEX idx_people_email ON people (LOWER(email));

> Importante porque PostgreSQL es case-sensitive.

---

# ğŸŸ¦ 9. MigraciÃ³n real de lÃ³gica desde Tâ€‘SQL

Ejemplo: procedimiento complejo de facturaciÃ³n.

### SQL Server

CREATE PROCEDURE CloseInvoice

Â Â Â  @InvoiceId INT

AS

BEGIN

Â Â Â  DECLARE @Total DECIMAL(10,2);

  

Â Â Â  SELECT @Total = SUM(Amount)

Â Â Â  FROM InvoiceItems

Â Â Â  WHERE InvoiceId = @InvoiceId;

  

Â Â Â  UPDATE Invoices

Â Â Â  SET Total = @Total, Status='Closed'

Â Â Â  WHERE Id = @InvoiceId;

END

### PostgreSQL

CREATE OR REPLACE FUNCTION close_invoice(invoice_id INTEGER)

RETURNS VOID AS $

DECLARE

Â Â Â  total NUMERIC(10,2);

BEGIN

Â Â Â  SELECT SUM(amount)

Â Â Â  INTO total

Â Â Â  FROM invoice_items

Â Â Â  WHERE invoice_id = close_invoice.invoice_id;

  

Â Â Â  UPDATE invoices

Â Â Â  SET total = total, status = 'Closed'

Â Â Â  WHERE id = close_invoice.invoice_id;

END;

$ LANGUAGE plpgsql;

âœ” Misma lÃ³gica  
âœ” Sintaxis diferente

---

# ğŸŸ¦ 10. Multitenancy por esquema (tu caso)

Tu estrategia funciona perfectamente en PostgreSQL:

CREATE SCHEMA tenant_001;

CREATE TABLE tenant_001.users (...);

Cambiar search_path:

SET search_path TO tenant_001;

---

# ğŸŸ¦ 11. Azure PostgreSQL Flexible Server

Recomendaciones:

- Usa **General Purpose** (no Basic Tier) para producciÃ³n
- Habilita `pg_cron` para tareas internas
- Ajusta `max_connections` (PostgreSQL no maneja tantas como SQL Server)
- Usa pgbouncer para pooling
- Habilita **High Availability Zone-Redundant**
- Configura `log_min_duration_statement` para diagnosticar lentos

---

# ğŸŸ¦ 12. Extensiones recomendadas

|ExtensiÃ³n|PropÃ³sito|Ãštil para|
|---|---|---|
|`pgvector`|IA embeddings|Recomendaciones, bÃºsqueda semÃ¡ntica|
|`pg_cron`|Jobs programados|Microâ€‘SaaS sin Azure Functions|
|`postgis`|GIS avanzado|Rutas, mapas, logÃ­stica|
|`timescaledb`|Series de tiempo|TelemetrÃ­a, IoT|
|`citus`|Escalamiento horizontal|SaaS grandes|
|`uuid-ossp`|GeneraciÃ³n de UUID|Identificadores|

---

# ğŸŸ¦ 13. Cheatsheets finales (para imprimir)

## SELECT equivalencia

TOP â†’ LIMIT

OFFSET â†’ OFFSET

ISNULL â†’ COALESCE

LEN â†’ LENGTH

GETDATE â†’ NOW

INSERT ... OUTPUT â†’ INSERT ... RETURNING

## Procedimientos

SQL Server:

CREATE PROCEDURE â†’ PostgreSQL: CREATE FUNCTION

OUTPUT â†’ RETURNING

PRINT â†’ RAISE NOTICE

INSERTED â†’ NEW

DELETED â†’ OLD

---

# ğŸŸ¦ 14. Â¿Quieres que lo convierta en PDF, Word o un archivo Markdown listo para tu repositorio?

Puedo generarte:

- ğŸ“„ PDF
- ğŸ“ Word (.docx)
- ğŸ“˜ Markdown (.md)
- ğŸ§± VersiÃ³n para MkDocs con navegaciÃ³n
- ğŸ“š VersiÃ³n optimizada para NotebookLM

Â¿CuÃ¡l formato quieres que genere primero?


