
<!--
@TDD:enabled
@TestFramework:xUnit
@Mocking:NSubstitute
@BoundedContext:AccountsPayable
@Architecture:CleanArchitecture+DDD+CQRS
-->




# Accounts Payable – Enhanced Bounded Context

> **Domain Group:** Core Accounting  
> **Generated:** 2025-09-23  
> **Enhanced for:** C# / .NET 8 / Visual Studio 2022  
> **Architecture:** Clean Architecture + DDD + CQRS + Event Sourcing

## Purpose
Manages the complete **Accounts Payable** lifecycle: vendor bill entry and validation, approval workflows, payment scheduling and execution, and vendor credit management. Provides seamless integration with **General Ledger** and **Banking** contexts, along with comprehensive reporting for aging analysis and cash flow forecasting.

---

## Context Boundaries

**Owns:**
- Complete vendor bill lifecycle and multi-level approval workflows
- Payment run scheduling, optimization, and execution coordination
- Vendor credit management and application logic
- AP aging reports and cash flow forecasting
- Audit trail for all AP operations

**Does NOT Own:**
- **Vendor master data** (Vendor Management context)
- **Bank account management** (Banking context)
- **General ledger posting mechanics** (General Ledger context)
- **Purchase order validation** (Procurement context)
- **Tax calculation logic** (Tax Management context)

---

## Ubiquitous Language

| Term | Definition |
|---|---|
| **Vendor Bill** | Invoice received from supplier for goods or services delivered |
| **Payment Run** | Batch processing of multiple payments scheduled for specific execution date |
| **Three-Way Match** | Validation of vendor bill against Purchase Order and Goods Receipt |
| **Vendor Credit** | Credit memo from supplier that offsets outstanding payable balances |
| **Early Payment Discount** | Supplier discount for payment before standard due date |
| **Aging Bucket** | Classification of bills by days overdue (Current, 1-30, 31-60, 61-90, 90+ days) |
| **Cash Forecast** | Projection of required funds for upcoming payment obligations |
| **Approval Threshold** | Monetary limit requiring specific authorization levels |

---

## Domain Model

### Aggregates

#### [Aggregate] VendorBill
```csharp
public class VendorBill : AggregateRoot<Guid>
{
    private readonly List<BillLineItem> _lineItems = new();
    
    public Guid TenantId { get; private set; }
    public Guid VendorId { get; private set; }
    public string InvoiceNumber { get; private set; } = string.Empty;
    public DateTime InvoiceDate { get; private set; }
    public DateTime DueDate { get; private set; }
    public ApprovalStatus ApprovalStatus { get; private set; }
    public PaymentStatus PaymentStatus { get; private set; }
    public Money TotalAmount { get; private set; }
    public Money RemainingBalance { get; private set; }
    public string? DocumentPath { get; private set; }
    public string? Notes { get; private set; }
    public IReadOnlyList<BillLineItem> LineItems => _lineItems.AsReadOnly();
    
    public static VendorBill Create(Guid tenantId, Guid vendorId, string invoiceNumber, 
        DateTime invoiceDate, DateTime dueDate, List<BillLineItem> lineItems, 
        string? documentPath = null, string? notes = null)
    {
        var bill = new VendorBill
        {
            Id = Guid.NewGuid(),
            TenantId = tenantId,
            VendorId = vendorId,
            InvoiceNumber = invoiceNumber,
            InvoiceDate = invoiceDate,
            DueDate = dueDate,
            ApprovalStatus = ApprovalStatus.Pending,
            PaymentStatus = PaymentStatus.Unpaid,
            DocumentPath = documentPath,
            Notes = notes
        };
        
        bill._lineItems.AddRange(lineItems);
        bill.CalculateTotals();
        
        bill.AddDomainEvent(new VendorBillCreatedEvent(
            tenantId, bill.Id, vendorId, invoiceNumber, 
            bill.TotalAmount, invoiceDate, dueDate, DateTime.UtcNow));
            
        return bill;
    }
    
    public void Approve(Guid approverId, string? notes = null)
    {
        if (ApprovalStatus != ApprovalStatus.Pending)
            throw new InvalidOperationException($"Cannot approve bill in status {ApprovalStatus}");
            
        ApprovalStatus = ApprovalStatus.Approved;
        AddDomainEvent(new VendorBillApprovedEvent(TenantId, Id, approverId, notes, DateTime.UtcNow));
    }
    
    public void Reject(Guid rejectedBy, string reason)
    {
        if (ApprovalStatus != ApprovalStatus.Pending)
            throw new InvalidOperationException($"Cannot reject bill in status {ApprovalStatus}");
            
        ApprovalStatus = ApprovalStatus.Rejected;
        AddDomainEvent(new VendorBillRejectedEvent(TenantId, Id, rejectedBy, reason, DateTime.UtcNow));
    }
    
    public void ApplyPayment(Money paymentAmount)
    {
        if (paymentAmount.Currency != TotalAmount.Currency)
            throw new InvalidOperationException("Payment currency must match bill currency");
            
        if (paymentAmount.Amount > RemainingBalance.Amount)
            throw new InvalidOperationException("Payment amount exceeds remaining balance");
            
        RemainingBalance = new Money(RemainingBalance.Amount - paymentAmount.Amount, RemainingBalance.Currency);
        
        UpdatePaymentStatus();
        AddDomainEvent(new PaymentAppliedEvent(TenantId, Id, paymentAmount, DateTime.UtcNow));
    }
    
    private void UpdatePaymentStatus()
    {
        PaymentStatus = RemainingBalance.Amount switch
        {
            0 => PaymentStatus.FullyPaid,
            var amount when amount < TotalAmount.Amount => PaymentStatus.PartiallyPaid,
            _ => PaymentStatus.Unpaid
        };
    }
    
    private void CalculateTotals()
    {
        var currency = _lineItems.First().UnitPrice.Currency;
        var total = _lineItems.Sum(item => item.LineTotal.Amount);
        TotalAmount = new Money(total, currency);
        RemainingBalance = TotalAmount;
    }
}
```

#### [Aggregate] PaymentRun
```csharp
public class PaymentRun : AggregateRoot<Guid>
{
    private readonly List<PaymentInstruction> _instructions = new();
    
    public Guid TenantId { get; private set; }
    public DateTime ScheduledDate { get; private set; }
    public PaymentMethod PaymentMethod { get; private set; }
    public PaymentRunStatus Status { get; private set; }
    public Money TotalAmount { get; private set; }
    public string? Notes { get; private set; }
    public IReadOnlyList<PaymentInstruction> Instructions => _instructions.AsReadOnly();
    
    public static PaymentRun Create(Guid tenantId, DateTime scheduledDate, 
        PaymentMethod paymentMethod, List<PaymentInstruction> instructions, string? notes = null)
    {
        var run = new PaymentRun
        {
            Id = Guid.NewGuid(),
            TenantId = tenantId,
            ScheduledDate = scheduledDate,
            PaymentMethod = paymentMethod,
            Status = PaymentRunStatus.Scheduled,
            Notes = notes
        };
        
        run._instructions.AddRange(instructions);
        run.CalculateTotalAmount();
        
        run.AddDomainEvent(new PaymentRunScheduledEvent(
            tenantId, run.Id, scheduledDate, paymentMethod, run.TotalAmount, DateTime.UtcNow));
            
        return run;
    }
    
    public void Execute()
    {
        if (Status != PaymentRunStatus.Scheduled)
            throw new InvalidOperationException($"Cannot execute payment run in status {Status}");
            
        Status = PaymentRunStatus.InProgress;
        AddDomainEvent(new PaymentRunExecutionStartedEvent(TenantId, Id, DateTime.UtcNow));
    }
    
    public void Complete()
    {
        if (Status != PaymentRunStatus.InProgress)
            throw new InvalidOperationException($"Cannot complete payment run in status {Status}");
            
        Status = PaymentRunStatus.Completed;
        AddDomainEvent(new PaymentRunCompletedEvent(TenantId, Id, DateTime.UtcNow));
    }
    
    private void CalculateTotalAmount()
    {
        if (_instructions.Any())
        {
            var currency = _instructions.First().Amount.Currency;
            var total = _instructions.Sum(i => i.Amount.Amount);
            TotalAmount = new Money(total, currency);
        }
    }
}
```

#### [Aggregate] VendorCredit
```csharp
public class VendorCredit : AggregateRoot<Guid>
{
    private readonly List<CreditApplication> _applications = new();
    
    public Guid TenantId { get; private set; }
    public Guid VendorId { get; private set; }
    public string CreditMemoNumber { get; private set; } = string.Empty;
    public DateTime CreditDate { get; private set; }
    public Money TotalAmount { get; private set; }
    public Money RemainingBalance { get; private set; }
    public string? Reason { get; private set; }
    public IReadOnlyList<CreditApplication> Applications => _applications.AsReadOnly();
    
    public void ApplyToVendorBill(Guid vendorBillId, Money applicationAmount, Guid appliedBy)
    {
        if (applicationAmount.Amount > RemainingBalance.Amount)
            throw new InvalidOperationException("Application amount exceeds remaining credit balance");
            
        var application = new CreditApplication(vendorBillId, applicationAmount, appliedBy, DateTime.UtcNow);
        _applications.Add(application);
        
        RemainingBalance = new Money(RemainingBalance.Amount - applicationAmount.Amount, RemainingBalance.Currency);
        
        AddDomainEvent(new VendorCreditAppliedEvent(
            TenantId, Id, vendorBillId, applicationAmount, appliedBy, DateTime.UtcNow));
    }
}
```

### Value Objects

#### [ValueObject] Money
```csharp
public readonly record struct Money(decimal Amount, string Currency)
{
    public static Money Zero(string currency) => new(0m, currency);
    
    public static Money operator +(Money left, Money right)
    {
        if (left.Currency != right.Currency)
            throw new InvalidOperationException("Cannot add different currencies");
        return new Money(left.Amount + right.Amount, left.Currency);
    }
    
    public static Money operator -(Money left, Money right)
    {
        if (left.Currency != right.Currency)
            throw new InvalidOperationException("Cannot subtract different currencies");
        return new Money(left.Amount - right.Amount, left.Currency);
    }
    
    public bool IsPositive => Amount > 0;
    public bool IsNegative => Amount < 0;
    public bool IsZero => Amount == 0;
}
```

#### [ValueObject] BillLineItem
```csharp
public record BillLineItem(
    string Description,
    decimal Quantity,
    Money UnitPrice,
    string? AccountCode = null,
    string? TaxCode = null,
    string? ProjectCode = null)
{
    public Money LineTotal => new(Quantity * UnitPrice.Amount, UnitPrice.Currency);
}
```

#### [ValueObject] PaymentInstruction
```csharp
public record PaymentInstruction(
    Guid VendorBillId,
    Guid VendorId,
    Money Amount,
    string? Reference = null);
```

#### [ValueObject] CreditApplication
```csharp
public record CreditApplication(
    Guid VendorBillId,
    Money Amount,
    Guid AppliedBy,
    DateTime AppliedAt);
```

### Enums
```csharp
public enum ApprovalStatus
{
    Pending,
    Approved,
    Rejected,
    RequiresReview
}

public enum PaymentStatus
{
    Unpaid,
    PartiallyPaid,
    FullyPaid,
    Cancelled
}

public enum PaymentMethod
{
    Check,
    ACH,
    Wire,
    CreditCard
}

public enum PaymentRunStatus
{
    Scheduled,
    InProgress,
    Completed,
    Failed,
    Cancelled
}
```

### Domain Services

#### [DomainService] DuplicateDetectionService
```csharp
public interface IDuplicateDetectionService
{
    Task<bool> IsDuplicateAsync(string invoiceNumber, Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<IEnumerable<VendorBill>> FindSimilarBillsAsync(VendorBill bill, CancellationToken cancellationToken = default);
}
```

#### [DomainService] PaymentOptimizationService
```csharp
public interface IPaymentOptimizationService
{
    Task<IEnumerable<PaymentRecommendation>> OptimizePaymentScheduleAsync(
        IEnumerable<VendorBill> bills, DateTime maxPaymentDate, CancellationToken cancellationToken = default);
    Task<decimal> CalculateEarlyPaymentSavingsAsync(VendorBill bill, DateTime proposedPaymentDate, CancellationToken cancellationToken = default);
}
```

#### [DomainService] ThreeWayMatchingService
```csharp
public interface IThreeWayMatchingService
{
    Task<MatchResult> ValidateThreeWayMatchAsync(VendorBill bill, Guid purchaseOrderId, Guid goodsReceiptId, CancellationToken cancellationToken = default);
    Task<IEnumerable<MatchDiscrepancy>> GetDiscrepanciesAsync(VendorBill bill, Guid purchaseOrderId, CancellationToken cancellationToken = default);
}
```

#### [DomainService] CashForecastingService
```csharp
public interface ICashForecastingService
{
    Task<CashRequirementForecast> ForecastRequirementsAsync(int forecastDays, Guid tenantId, CancellationToken cancellationToken = default);
    Task<IEnumerable<CashFlowItem>> GetUpcomingObligationsAsync(DateTime fromDate, DateTime toDate, Guid tenantId, CancellationToken cancellationToken = default);
}
```

### Repository Contracts

#### [Repository] IVendorBillRepository
```csharp
public interface IVendorBillRepository : IAggregateRepository<VendorBill>
{
    Task<VendorBill?> GetByInvoiceNumberAsync(string invoiceNumber, Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<VendorBill>> GetPendingApprovalAsync(Guid tenantId, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<VendorBill>> GetReadyForPaymentAsync(DateTime dueDate, Guid tenantId, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<VendorBill>> GetByVendorAsync(Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<bool> ExistsAsync(string invoiceNumber, Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<VendorBill>> GetOverdueAsync(DateTime asOfDate, Guid tenantId, CancellationToken cancellationToken = default);
}
```

#### [Repository] IPaymentRunRepository
```csharp
public interface IPaymentRunRepository : IAggregateRepository<PaymentRun>
{
    Task<PaymentRun?> GetActiveRunAsync(Guid tenantId, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<PaymentRun>> GetByDateRangeAsync(DateTime fromDate, DateTime toDate, Guid tenantId, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<PaymentRun>> GetScheduledRunsAsync(DateTime executionDate, CancellationToken cancellationToken = default);
}
```

#### [Repository] IVendorCreditRepository
```csharp
public interface IVendorCreditRepository : IAggregateRepository<VendorCredit>
{
    Task<IReadOnlyList<VendorCredit>> GetByVendorAsync(Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<IReadOnlyList<VendorCredit>> GetAvailableCreditsAsync(Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<VendorCredit?> GetByCreditMemoNumberAsync(string creditMemoNumber, Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
}
```

---

## Domain & Integration Events

### Domain Events

#### [Event] VendorBillCreatedEvent
```csharp
public record VendorBillCreatedEvent(
    Guid TenantId,
    Guid VendorBillId,
    Guid VendorId,
    string InvoiceNumber,
    Money TotalAmount,
    DateTime InvoiceDate,
    DateTime DueDate,
    DateTime CreatedAt) : IDomainEvent;
```

#### [Event] VendorBillApprovedEvent
```csharp
public record VendorBillApprovedEvent(
    Guid TenantId,
    Guid VendorBillId,
    Guid ApproverId,
    string? Notes,
    DateTime ApprovedAt) : IDomainEvent;
```

#### [Event] VendorBillRejectedEvent
```csharp
public record VendorBillRejectedEvent(
    Guid TenantId,
    Guid VendorBillId,
    Guid RejectedBy,
    string Reason,
    DateTime RejectedAt) : IDomainEvent;
```

#### [Event] PaymentRunScheduledEvent
```csharp
public record PaymentRunScheduledEvent(
    Guid TenantId,
    Guid PaymentRunId,
    DateTime ScheduledDate,
    PaymentMethod PaymentMethod,
    Money TotalAmount,
    DateTime ScheduledAt) : IDomainEvent;
```

#### [Event] PaymentRunCompletedEvent
```csharp
public record PaymentRunCompletedEvent(
    Guid TenantId,
    Guid PaymentRunId,
    DateTime CompletedAt) : IDomainEvent;
```

#### [Event] VendorCreditAppliedEvent
```csharp
public record VendorCreditAppliedEvent(
    Guid TenantId,
    Guid VendorCreditId,
    Guid VendorBillId,
    Money ApplicationAmount,
    Guid AppliedBy,
    DateTime AppliedAt) : IDomainEvent;
```

#### [Event] PaymentAppliedEvent
```csharp
public record PaymentAppliedEvent(
    Guid TenantId,
    Guid VendorBillId,
    Money PaymentAmount,
    DateTime AppliedAt) : IDomainEvent;
```

### Integration Events (Published)

#### [Event] VendorBillPostedEvent
```csharp
public record VendorBillPostedEvent(
    Guid TenantId,
    Guid VendorBillId,
    Guid VendorId,
    Money Amount,
    IEnumerable<AccountingEntry> Entries,
    DateTime PostedAt) : IIntegrationEvent;
```

#### [Event] PaymentProcessedEvent
```csharp
public record PaymentProcessedEvent(
    Guid TenantId,
    Guid PaymentRunId,
    Guid VendorBillId,
    Money Amount,
    PaymentMethod Method,
    string? TransactionReference,
    DateTime ProcessedAt) : IIntegrationEvent;
```

#### [Event] CashFlowImpactEvent
```csharp
public record CashFlowImpactEvent(
    Guid TenantId,
    DateTime ImpactDate,
    Money Amount,
    string Description,
    CashFlowType Type,
    DateTime PublishedAt) : IIntegrationEvent;
```

### Integration Events (Subscribed)

#### [Event] VendorOnboardedEvent
```csharp
public record VendorOnboardedEvent(
    Guid TenantId,
    Guid VendorId,
    string VendorName,
    PaymentTerms DefaultPaymentTerms,
    DateTime OnboardedAt) : IIntegrationEvent;
```

#### [Event] PurchaseOrderApprovedEvent
```csharp
public record PurchaseOrderApprovedEvent(
    Guid TenantId,
    Guid PurchaseOrderId,
    Guid VendorId,
    Money TotalAmount,
    DateTime ApprovedAt) : IIntegrationEvent;
```

---

## Commands & Queries

### Commands

#### [Command] EnterVendorBillCommand
```csharp
public record EnterVendorBillCommand(
    [Required] Guid TenantId,
    [Required] Guid VendorId,
    [Required, MaxLength(50)] string InvoiceNumber,
    [Required] DateTime InvoiceDate,
    [Required] DateTime DueDate,
    [Required, MinLength(1)] List<BillLineItem> LineItems,
    [MaxLength(500)] string? DocumentPath = null,
    [MaxLength(1000)] string? Notes = null,
    Guid? PurchaseOrderId = null) : ICommand<Guid>;
```

#### [Command] ApproveVendorBillCommand
```csharp
public record ApproveVendorBillCommand(
    [Required] Guid TenantId,
    [Required] Guid VendorBillId,
    [Required] Guid ApproverId,
    [MaxLength(500)] string? Notes = null,
    DateTime? ApprovalDate = null) : ICommand;
```

#### [Command] SchedulePaymentRunCommand
```csharp
public record SchedulePaymentRunCommand(
    [Required] Guid TenantId,
    [Required] DateTime PaymentDate,
    [Required] List<Guid> VendorBillIds,
    [Required] PaymentMethod PaymentMethod,
    [MaxLength(500)] string? Notes = null) : ICommand<Guid>;
```

#### [Command] ApplyVendorCreditCommand
```csharp
public record ApplyVendorCreditCommand(
    [Required] Guid TenantId,
    [Required] Guid VendorCreditId,
    [Required] Guid VendorBillId,
    [Required] decimal AmountToApply,
    [Required] Guid AppliedBy) : ICommand;
```

### Command Handlers

#### [Handler] EnterVendorBillCommandHandler
```csharp
public class EnterVendorBillCommandHandler : ICommandHandler<EnterVendorBillCommand, Guid>
{
    private readonly IVendorBillRepository _repository;
    private readonly IDuplicateDetectionService _duplicateDetection;
    private readonly IThreeWayMatchingService _threeWayMatching;
    private readonly ILogger<EnterVendorBillCommandHandler> _logger;
    
    public EnterVendorBillCommandHandler(
        IVendorBillRepository repository,
        IDuplicateDetectionService duplicateDetection,
        IThreeWayMatchingService threeWayMatching,
        ILogger<EnterVendorBillCommandHandler> logger)
    {
        _repository = repository;
        _duplicateDetection = duplicateDetection;
        _threeWayMatching = threeWayMatching;
        _logger = logger;
    }
    
    public async Task<Guid> HandleAsync(EnterVendorBillCommand command, CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Processing vendor bill for invoice {InvoiceNumber}", command.InvoiceNumber);
        
        // Validate business rules
        if (command.DueDate < command.InvoiceDate)
            throw new BusinessRuleViolationException("Due date cannot be earlier than invoice date");
        
        // Check for duplicates
        if (await _duplicateDetection.IsDuplicateAsync(command.InvoiceNumber, command.VendorId, command.TenantId, cancellationToken))
        {
            throw new DuplicateInvoiceException($"Invoice {command.InvoiceNumber} already exists for vendor {command.VendorId}");
        }
        
        var vendorBill = VendorBill.Create(
            command.TenantId,
            command.VendorId,
            command.InvoiceNumber,
            command.InvoiceDate,
            command.DueDate,
            command.LineItems,
            command.DocumentPath,
            command.Notes);
        
        // Perform three-way matching if PO is provided
        if (command.PurchaseOrderId.HasValue)
        {
            var matchResult = await _threeWayMatching.ValidateThreeWayMatchAsync(
                vendorBill, command.PurchaseOrderId.Value, Guid.Empty, cancellationToken);
                
            if (!matchResult.IsMatch)
            {
                _logger.LogWarning("Three-way match failed for bill {VendorBillId}", vendorBill.Id);
                // Handle match failure based on business rules
            }
        }
        
        await _repository.SaveAsync(vendorBill, cancellationToken);
        
        _logger.LogInformation("Vendor bill {VendorBillId} created successfully", vendorBill.Id);
        
        return vendorBill.Id;
    }
}
```

### Read Models (CQRS)

#### [ReadModel] VendorBillSummaryReadModel
```csharp
public class VendorBillSummaryReadModel
{
    public Guid Id { get; set; }
    public Guid TenantId { get; set; }
    public string VendorName { get; set; } = string.Empty;
    public string InvoiceNumber { get; set; } = string.Empty;
    public decimal Amount { get; set; }
    public string Currency { get; set; } = string.Empty;
    public ApprovalStatus ApprovalStatus { get; set; }
    public PaymentStatus PaymentStatus { get; set; }
    public DateTime InvoiceDate { get; set; }
    public DateTime DueDate { get; set; }
    public decimal RemainingBalance { get; set; }
    public int DaysOverdue => DueDate < DateTime.Today ? (DateTime.Today - DueDate).Days : 0;
    public string? DocumentPath { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ApprovedAt { get; set; }
}
```

#### [ReadModel] PaymentRunSummaryReadModel
```csharp
public class PaymentRunSummaryReadModel
{
    public Guid Id { get; set; }
    public Guid TenantId { get; set; }
    public DateTime ScheduledDate { get; set; }
    public int BillCount { get; set; }
    public decimal TotalAmount { get; set; }
    public string Currency { get; set; } = string.Empty;
    public PaymentMethod PaymentMethod { get; set; }
    public PaymentRunStatus Status { get; set; }
    public string? Notes { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ExecutedAt { get; set; }
}
```

#### [ReadModel] APAgingSummaryReadModel
```csharp
public class APAgingSummaryReadModel
{
    public Guid TenantId { get; set; }
    public Guid VendorId { get; set; }
    public string VendorName { get; set; } = string.Empty;
    public string Currency { get; set; } = string.Empty;
    public decimal CurrentAmount { get; set; }
    public decimal Days1To30Amount { get; set; }
    public decimal Days31To60Amount { get; set; }
    public decimal Days61To90Amount { get; set; }
    public decimal Days90PlusAmount { get; set; }
    public decimal TotalAmount => CurrentAmount + Days1To30Amount + Days31To60Amount + Days61To90Amount + Days90PlusAmount;
    public DateTime LastUpdated { get; set; }
}
```

#### [ReadModel] CashRequirementForecastReadModel
```csharp
public class CashRequirementForecastReadModel
{
    public Guid TenantId { get; set; }
    public DateTime ForecastDate { get; set; }
    public string Currency { get; set; } = string.Empty;
    public decimal Next7DaysRequirement { get; set; }
    public decimal Next30DaysRequirement { get; set; }
    public decimal Next90DaysRequirement { get; set; }
    public decimal AvailableCashBalance { get; set; }
    public decimal ProjectedShortfall => Math.Max(0, Next30DaysRequirement - AvailableCashBalance);
    public List<CashFlowItem> UpcomingObligations { get; set; } = new();
    public DateTime GeneratedAt { get; set; }
}
```

---

## Business Rules

### VendorBill Aggregate Rules
- Invoice numbers must be **unique per vendor per tenant**
- Bills cannot be paid without **approval**
- Line item total must equal **sum of (quantity × unit price) + taxes**
- Bills exceeding approval threshold require **multi-level approval**
- **Due date ≥ Invoice date**
- **Remaining balance ≤ Total amount**
- Bills in "Rejected" status cannot be approved
- Payment applications cannot exceed remaining balance

### PaymentRun Aggregate Rules
- Only **approved bills** can be included in payment runs
- Payment runs cannot be modified once **execution starts**
- Total run amount cannot exceed **available cash balance**
- Execution date must be **current or future date**
- Bills can only belong to **one active payment run**
- Cancelled runs release all associated bills

### VendorCredit Aggregate Rules
- Credits can only be applied to **same vendor bills**
- Application amount ≤ **remaining credit balance**
- Application amount ≤ **bill remaining balance**
- Credit applications are **immutable** once created
- Credits reduce payable balance immediately

---

## Anti-Corruption Layers (ACL)

### [ACL] General Ledger Integration
```csharp
public interface IGeneralLedgerService
{
    Task<Result> PostAccountingEntryAsync(VendorBillPostedEvent billPosted, CancellationToken cancellationToken = default);
    Task<Result> PostPaymentEntryAsync(PaymentProcessedEvent paymentProcessed, CancellationToken cancellationToken = default);
    Task<Result> PostReversalEntryAsync(PaymentReversedEvent paymentReversed, CancellationToken cancellationToken = default);
    Task<IEnumerable<AccountCode>> GetValidAccountCodesAsync(Guid tenantId, CancellationToken cancellationToken = default);
}

public class GeneralLedgerServiceAdapter : IGeneralLedgerService
{
    private readonly IExternalGeneralLedgerClient _client;
    private readonly IMapper _mapper;
    private readonly ILogger<GeneralLedgerServiceAdapter> _logger;
    
    public GeneralLedgerServiceAdapter(
        IExternalGeneralLedgerClient client, 
        IMapper mapper, 
        ILogger<GeneralLedgerServiceAdapter> logger)
    {
        _client = client;
        _mapper = mapper;
        _logger = logger;
    }
    
    public async Task<Result> PostAccountingEntryAsync(VendorBillPostedEvent billPosted, CancellationToken cancellationToken = default)
    {
        try
        {
            var externalEntry = _mapper.Map<ExternalAccountingEntry>(billPosted);
            var response = await _client.PostEntryAsync(externalEntry, cancellationToken);
            
            return response.IsSuccess 
                ? Result.Success() 
                : Result.Failure($"GL posting failed: {response.ErrorMessage}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to post accounting entry for bill {VendorBillId}", billPosted.VendorBillId);
            return Result.Failure($"GL integration error: {ex.Message}");
        }
    }
    
    public async Task<Result> PostPaymentEntryAsync(PaymentProcessedEvent paymentProcessed, CancellationToken cancellationToken = default)
    {
        try
        {
            var externalEntry = _mapper.Map<ExternalPaymentEntry>(paymentProcessed);
            var response = await _client.PostPaymentAsync(externalEntry, cancellationToken);
            
            return response.IsSuccess 
                ? Result.Success() 
                : Result.Failure($"Payment posting failed: {response.ErrorMessage}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to post payment entry for bill {VendorBillId}", paymentProcessed.VendorBillId);
            return Result.Failure($"GL integration error: {ex.Message}");
        }
    }
    
    public async Task<Result> PostReversalEntryAsync(PaymentReversedEvent paymentReversed, CancellationToken cancellationToken = default)
    {
        try
        {
            var externalEntry = _mapper.Map<ExternalReversalEntry>(paymentReversed);
            var response = await _client.PostReversalAsync(externalEntry, cancellationToken);
            
            return response.IsSuccess 
                ? Result.Success() 
                : Result.Failure($"Reversal posting failed: {response.ErrorMessage}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to post reversal entry for payment {PaymentId}", paymentReversed.PaymentId);
            return Result.Failure($"GL integration error: {ex.Message}");
        }
    }
    
    public async Task<IEnumerable<AccountCode>> GetValidAccountCodesAsync(Guid tenantId, CancellationToken cancellationToken = default)
    {
        try
        {
            var response = await _client.GetAccountCodesAsync(tenantId, cancellationToken);
            return _mapper.Map<IEnumerable<AccountCode>>(response.Data);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to retrieve account codes for tenant {TenantId}", tenantId);
            return Enumerable.Empty<AccountCode>();
        }
    }
}
```

### [ACL] Banking Integration
```csharp
public interface IBankingService
{
    Task<Result<PaymentResult>> InitiateACHPaymentAsync(PaymentInstruction instruction, CancellationToken cancellationToken = default);
    Task<Result<PaymentResult>> InitiateWirePaymentAsync(PaymentInstruction instruction, CancellationToken cancellationToken = default);
    Task<Result<PaymentResult>> InitiateCheckPaymentAsync(PaymentInstruction instruction, CancellationToken cancellationToken = default);
    Task<Result<BankAccountValidation>> ValidateBankAccountAsync(BankAccountDetails account, CancellationToken cancellationToken = default);
    Task<Result<decimal>> GetAvailableBalanceAsync(Guid accountId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<Result<IEnumerable<PaymentStatus>>> GetPaymentStatusUpdatesAsync(Guid tenantId, DateTime since, CancellationToken cancellationToken = default);
}

public class BankingServiceAdapter : IBankingService
{
    private readonly IExternalBankingClient _client;
    private readonly IMapper _mapper;
    private readonly ILogger<BankingServiceAdapter> _logger;
    
    public BankingServiceAdapter(
        IExternalBankingClient client, 
        IMapper mapper, 
        ILogger<BankingServiceAdapter> logger)
    {
        _client = client;
        _mapper = mapper;
        _logger = logger;
    }
    
    public async Task<Result<PaymentResult>> InitiateACHPaymentAsync(PaymentInstruction instruction, CancellationToken cancellationToken = default)
    {
        try
        {
            var externalInstruction = _mapper.Map<ExternalACHInstruction>(instruction);
            var response = await _client.ProcessACHPaymentAsync(externalInstruction, cancellationToken);
            
            return response.IsSuccess 
                ? Result<PaymentResult>.Success(_mapper.Map<PaymentResult>(response.Data))
                : Result<PaymentResult>.Failure($"ACH payment failed: {response.ErrorMessage}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initiate ACH payment for bill {VendorBillId}", instruction.VendorBillId);
            return Result<PaymentResult>.Failure($"Banking integration error: {ex.Message}");
        }
    }
    
    public async Task<Result<decimal>> GetAvailableBalanceAsync(Guid accountId, Guid tenantId, CancellationToken cancellationToken = default)
    {
        try
        {
            var response = await _client.GetAccountBalanceAsync(accountId, tenantId, cancellationToken);
            return response.IsSuccess 
                ? Result<decimal>.Success(response.Data.AvailableBalance)
                : Result<decimal>.Failure($"Balance inquiry failed: {response.ErrorMessage}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get available balance for account {AccountId}", accountId);
            return Result<decimal>.Failure($"Banking integration error: {ex.Message}");
        }
    }
}
```

### [ACL] Vendor Management Integration
```csharp
public interface IVendorManagementService
{
    Task<Result<Vendor>> GetVendorAsync(Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<Result<PaymentTerms>> GetPaymentTermsAsync(Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<Result<BankAccountDetails>> GetVendorBankAccountAsync(Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
    Task<Result<bool>> IsVendorActiveAsync(Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default);
}
```

---

## Use Cases (Overview)

| ID | Name | Intent | Segment | Level |
|---|---|---|---:|---:|
| **EnterVendorBill** | Enter Vendor Bill | Create and validate new vendor bill with comprehensive validation | MVP Small Business (SMB) | 2 |
| **ManageVendorCredits** | Manage Vendor Credits | Process credit memos and apply to outstanding bills | Enterprise SMB+ | 3 |
| **SchedulePaymentRun** | Schedule Payment Run | Batch and schedule payments with optimization | Enterprise SMB+ | 3 |
| **ForecastCashNeeds** | Forecast Cash Requirements | Calculate upcoming cash obligations and liquidity needs | SMB+ | 3 |

---

## Use Cases (Detail & TDD)

### 1) Enter Vendor Bill (`EnterVendorBill`)
**Intent**  
Create and validate vendor bills with comprehensive business rule enforcement, duplicate detection, and optional three-way matching against purchase orders and receipts.

**Target segment & maturity**  
- Segment: MVP Small Business (SMB)  
- Level: 2

**Future extensions (roadmap)**  
- Advanced approval workflows with parallel/serial routing
- ML-powered duplicate detection using invoice content similarity
- Automated three-way matching with tolerance management
- OCR integration for document processing
- Mobile approval capabilities

**Acceptance Criteria (Gherkin)**
```gherkin
Feature: Enter Vendor Bill in Accounts Payable bounded context
  As an AP clerk
  I want to register a supplier invoice with comprehensive validation
  So that it can be processed through approval workflow and payment execution

  Background:
    Given a registered vendor exists with valid payment terms
      And the current user has "AP_CLERK" permissions
      And the system has valid chart of accounts configured

  Scenario: Successfully create vendor bill with valid data
    Given the invoice number has not been used for this vendor
      And the invoice date is today or earlier
      And the due date is on or after the invoice date
      And all line items have valid account codes
    When I submit the bill with valid line items and taxes
    Then the system creates the bill with status "Pending"
      And emits a "VendorBillCreated" domain event
      And the remaining balance equals the total amount
      And an accounting entry request is queued for GL posting

  Scenario: Prevent duplicate invoice entry
    Given an existing bill for vendor V with invoice number "INV-001"
    When I submit another bill for vendor V with invoice number "INV-001"
    Then the system rejects the entry with "DuplicateInvoiceException"
      And suggests reviewing the existing bill
      And no domain events are emitted

  Scenario: Three-way match validation success
    Given the bill references PO "PO-123" with amount $1000
      And goods receipt "GR-456" confirms delivery of $1000
      And the bill amount is $1000
    When I submit the bill with PO reference
    Then the system validates three-way match successfully
      And creates the bill with status "Pending"
      And records match validation results

  Scenario: Three-way match validation failure
    Given the bill references PO "PO-123" with amount $1000
      And goods receipt "GR-456" confirms delivery of $800
      And the bill amount is $1000
    When I submit the bill with PO reference
    Then the system flags the bill as "RequiresReview"
      And records match discrepancies for review
      And notifies AP specialist of discrepancies

  Scenario: Validate business rules
    Given I attempt to create a bill where due date is before invoice date
    When I submit the bill
    Then the system rejects with "BusinessRuleViolationException"
      And provides clear error message about date validation

  Scenario: Handle approval threshold requirements
    Given a bill with total amount exceeding single approval limit
    When the bill is created successfully
    Then the system determines required approval levels
      And routes to appropriate approvers based on amount
      And tracks approval workflow status
```

**Test Design (tests-first)**
- [ ] **Unit Tests**: 
  - `VendorBill.Create()` factory method validation
  - `EnterVendorBillCommandHandler` business logic
  - Domain event emission verification
  - Business rule enforcement (dates, amounts, uniqueness)
  - Line item calculation accuracy
- [ ] **Integration Tests**: 
  - Repository persistence and retrieval
  - Duplicate detection service integration
  - Three-way matching service calls
  - Event publisher integration
- [ ] **Contract Tests**: 
  - `VendorBillCreated` event structure and subscribers
  - ACL interfaces for external service integration
- [ ] **E2E Tests**: 
  - Complete bill creation workflow
  - Approval routing based on thresholds
  - Integration with downstream systems

### 2) Manage Vendor Credits (`ManageVendorCredits`)
**Intent**  
Register vendor credit memos and apply them to outstanding bills with comprehensive audit trail and balance management.

**Target segment & maturity**  
- Segment: Enterprise SMB+  
- Level: 3

**Future extensions (roadmap)**  
- Automated credit matching against open bills
- Bulk credit application processing
- Credit aging and utilization reporting
- Integration with vendor statement reconciliation

**Acceptance Criteria (Gherkin)**
```gherkin
Feature: Manage Vendor Credits in Accounts Payable bounded context
  As an AP specialist
  I want to apply supplier credit memos to outstanding bills
  So that vendor balances accurately reflect net liabilities

  Background:
    Given a registered vendor with outstanding bills
      And valid credit memo from supplier
      And current user has "AP_SPECIALIST" permissions

  Scenario: Successfully apply credit to same vendor bill
    Given an approved credit memo C for vendor V with available balance $500
      And an open bill B for vendor V with remaining balance $800
    When I apply $300 from credit C to bill B
    Then bill B remaining balance becomes $500
      And credit C remaining balance becomes $200
      And a "VendorCreditApplied" event is emitted
      And an audit trail entry is recorded
      And accounting impact is calculated for GL posting

  Scenario: Prevent cross-vendor credit application
    Given a credit memo for vendor "ACME Corp"
      And an open bill for vendor "XYZ Ltd"
    When I attempt to apply the credit to the bill
    Then the system rejects with "VendorMismatchException"
      And provides clear error message
      And no changes are made to either entity

  Scenario: Prevent over-application of credit
    Given a credit memo with remaining balance $100
      And an open bill with remaining balance $80
    When I attempt to apply $120 from the credit
    Then the system rejects with "InsufficientCreditBalanceException"
      And suggests maximum applicable amount
      And no partial application is made

  Scenario: Handle currency mismatch
    Given a credit memo in USD currency
      And an open bill in EUR currency
    When I attempt to apply the credit
    Then the system rejects with "CurrencyMismatchException"
      And suggests currency conversion if supported
      And provides current exchange rates

  Scenario: Fully utilize credit memo
    Given a credit memo with remaining balance $100
      And an open bill with remaining balance $150
    When I apply the full credit amount of $100
    Then the bill remaining balance becomes $50
      And the credit memo is marked as "Fully Utilized"
      And appropriate domain events are emitted
```

**Test Design (tests-first)**
- [ ] **Unit Tests**: 
  - `VendorCredit.ApplyToVendorBill()` method logic
  - Credit application validation rules
  - Balance calculations and currency handling
  - Domain event emission for applications
- [ ] **Integration Tests**: 
  - Repository transactional updates
  - Cross-aggregate consistency verification
  - Event publishing and projection updates
- [ ] **Contract Tests**: 
  - `VendorCreditApplied` event structure
  - Read model projection accuracy
- [ ] **E2E Tests**: 
  - End-to-end credit application workflow
  - Audit trail generation and reporting

### 3) Schedule Payment Run (`SchedulePaymentRun`)
**Intent**  
Batch approved vendor bills into optimized payment runs with cash flow management, early payment discount optimization, and multi-method payment support.

**Target segment & maturity**  
- Segment: Enterprise SMB+  
- Level: 3

**Future extensions (roadmap)**  
- AI-powered payment optimization
  - Cash flow forecasting integration
  - Early payment discount maximization
  - Supplier relationship impact analysis
- Fraud detection and prevention
- Multi-bank account optimization
- Payment method cost analysis

**Acceptance Criteria (Gherkin)**
```gherkin
Feature: Schedule Payment Run in Accounts Payable bounded context
  As an AP manager
  I want to batch approved bills into optimized payment runs
  So that payments are processed efficiently with maximum cost savings

  Background:
    Given multiple approved bills ready for payment
      And sufficient available cash balance
      And current user has "AP_MANAGER" permissions
      And banking integration is operational

  Scenario: Create payment run for future date with cash validation
    Given 5 approved bills totaling $10,000
      And available cash balance of $15,000
      And scheduled payment date is next business day
    When I create a payment run with ACH payment method
    Then the run is created with status "Scheduled"
      And all 5 bills are included in the run
      And a "PaymentRunScheduled" event is emitted
      And cash reserve is allocated for the payment
      And execution job is scheduled for payment date

  Scenario: Exclude unapproved bills from payment run
    Given 3 approved bills and 2 pending bills
    When I attempt to include all bills in payment run
    Then only the 3 approved bills are included
      And the 2 pending bills are excluded with clear reasons
      And warnings are displayed for excluded bills
      And the run total reflects only approved bills

  Scenario: Handle insufficient cash balance
    Given approved bills totaling $20,000
      And available cash balance of $15,000
    When I attempt to create the payment run
    Then the system suggests partial payment options:
      | Option | Description | Amount |
      | Priority | Pay highest priority bills first | $15,000 |
      | Due Date | Pay oldest bills first | $15,000 |
      | Discount | Pay bills with early discounts | $12,000 |
    And allows manual bill selection within budget

  Scenario: Optimize for early payment discounts
    Given bills with early payment discount opportunities:
      | Bill | Amount | Discount % | Discount Deadline | Savings |
      | B1 | $1,000 | 2% | Tomorrow | $20 |
      | B2 | $2,000 | 1.5% | Next week | $30 |
      | B3 | $3,000 | 1% | Next month | $30 |
    When I request discount optimization
    Then the system recommends payment schedule:
      | Bill | Recommended Date | Savings | Reason |
      | B1 | Tomorrow | $20 | Discount expires soon |
      | B2 | Next week | $30 | Good discount rate |
      | B3 | Standard due date | $0 | Low discount, preserve cash |

  Scenario: Execute payment run successfully
    Given a scheduled payment run reaching execution time
      And banking services are available
      And all bills remain approved and unpaid
    When the system executes the payment run
    Then payments are initiated via banking integration
      And bill statuses are updated to "Payment Initiated"
      And "PaymentProcessed" events are published for each payment
      And run status becomes "InProgress"
      And GL accounting entries are queued

  Scenario: Handle payment execution failures
    Given a payment run with 3 bills during execution
      And 2 payments succeed while 1 fails due to invalid bank account
    When the execution completes
    Then successful payments are marked "Processed"
      And the failed payment is marked "Failed" with error details
      And the run status becomes "Partially Completed"
      And failed payments are queued for retry or manual review
      And notifications are sent to AP team
```

**Test Design (tests-first)**
- [ ] **Unit Tests**: 
  - `PaymentRun.Create()` factory validation
  - Bill selection and filtering logic
  - Payment optimization algorithms
  - Cash balance validation
  - Run execution state management
- [ ] **Integration Tests**: 
  - Banking service integration for payment initiation
  - Cash balance inquiry accuracy
  - Transaction rollback on partial failures
  - Event publishing for downstream systems
- [ ] **Contract Tests**: 
  - `PaymentRunScheduled` and `PaymentProcessed` event contracts
  - Banking ACL interface compliance
  - GL integration event structure
- [ ] **E2E Tests**: 
  - Complete payment run lifecycle
  - Multi-payment method processing
  - Error handling and recovery scenarios
  - Audit trail and reporting accuracy

### 4) Forecast Cash Requirements (`ForecastCashNeeds`)
**Intent**  
Calculate short-term and medium-term cash requirements for upcoming vendor payment obligations, providing liquidity planning insights for treasury management.

**Target segment & maturity**  
- Segment: SMB+  
- Level: 3

**Future extensions (roadmap)**  
- Machine learning for payment pattern prediction
- Integration with cash flow management system
- Scenario-based forecasting with different payment strategies
- Early payment discount impact analysis
- Supplier negotiation insights based on cash position

**Acceptance Criteria (Gherkin)**
```gherkin
Feature: Forecast Cash Requirements in Accounts Payable bounded context
  As an AP manager
  I want to forecast upcoming cash requirements for vendor payments
  So that I can ensure adequate liquidity and optimize cash management

  Background:
    Given multiple approved bills with various due dates
      And current available cash balance is known
      And current user has "AP_MANAGER" permissions

  Scenario: Generate 30-day cash requirement forecast
    Given approved bills due within 30 days totaling $50,000
      And scheduled payment runs totaling $20,000
      And current available balance of $60,000
    When I request a 30-day cash forecast
    Then the forecast shows:
      | Period | Required | Available | Surplus/Deficit |
      | Next 7 days | $15,000 | $60,000 | $45,000 surplus |
      | Next 30 days | $50,000 | $60,000 | $10,000 surplus |
    And includes breakdown by vendor and payment method
    And identifies critical payment dates

  Scenario: Identify cash shortfall scenario
    Given approved bills due within 30 days totaling $80,000
      And current available balance of $50,000
      And no additional cash inflows scheduled
    When I request a cash forecast
    Then the forecast highlights $30,000 shortfall
      And suggests mitigation strategies:
        | Strategy | Impact | Description |
        | Delay non-critical payments | -$15,000 | Extend payment terms where possible |
        | Capture early discounts | -$2,000 | Pay strategic bills early for savings |
        | Request payment deferrals | -$10,000 | Negotiate with key suppliers |
    And provides recommended actions with priorities

  Scenario: Include early payment discount opportunities
    Given bills with early payment discounts available
      And sufficient cash balance to capture discounts
    When I generate the forecast
    Then the system calculates discount savings potential:
      | Discount Opportunity | Amount | Discount | Savings | Payment Date |
      | Vendor A | $10,000 | 2% | $200 | 5 days early |
      | Vendor B | $5,000 | 1.5% | $75 | 10 days early |
    And includes net cash flow impact of early payments
    And recommends optimal discount capture strategy

  Scenario: Consider payment run scheduling impact
    Given existing scheduled payment runs
      And bills not yet included in runs
    When I forecast cash requirements
    Then the system considers:
      - Bills already scheduled for payment in existing runs
      - Bills eligible for inclusion in future runs
      - Optimal run timing for cash flow management
      - Payment method impacts on cash timing
    And provides run scheduling recommendations

  Scenario: Generate forecast with different time horizons
    Given bills distributed across various due dates
    When I request forecasts for different periods:
      | Period | Required Payments |
      | Next 7 days | $15,000 |
      | Next 30 days | $45,000 |
      | Next 60 days | $75,000 |
      | Next 90 days | $95,000 |
    Then each forecast includes confidence levels
      And identifies key assumptions and risks
      And provides sensitivity analysis for different scenarios
```

**Test Design (tests-first)**
- [ ] **Unit Tests**: 
  - `CashForecastingService` calculation logic
  - Date range filtering and grouping
  - Discount opportunity identification
  - Scenario comparison algorithms
- [ ] **Integration Tests**: 
  - Repository queries for bills and payment runs
  - Banking service integration for balance inquiries
  - External cash flow system integration
- [ ] **Contract Tests**: 
  - `CashFlowImpact` event publishing
  - Forecast data structure validation
- [ ] **E2E Tests**: 
  - Complete forecast generation workflow
  - Report accuracy and formatting
  - Integration with treasury management systems

---

## Infrastructure Implementation

### EF Core Configuration

#### DbContext
```csharp
public class AccountsPayableDbContext : DbContext
{
    private readonly ITenantService _tenantService;
    
    public AccountsPayableDbContext(DbContextOptions<AccountsPayableDbContext> options, ITenantService tenantService) 
        : base(options)
    {
        _tenantService = tenantService;
    }
    
    public DbSet<VendorBill> VendorBills { get; set; }
    public DbSet<PaymentRun> PaymentRuns { get; set; }
    public DbSet<VendorCredit> VendorCredits { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(AccountsPayableDbContext).Assembly);
        
        // Global tenant filter
        var tenantId = _tenantService.CurrentTenantId;
        modelBuilder.Entity<VendorBill>().HasQueryFilter(e => e.TenantId == tenantId);
        modelBuilder.Entity<PaymentRun>().HasQueryFilter(e => e.TenantId == tenantId);
        modelBuilder.Entity<VendorCredit>().HasQueryFilter(e => e.TenantId == tenantId);
    }
}
```

#### Entity Configurations
```csharp
public class VendorBillConfiguration : IEntityTypeConfiguration<VendorBill>
{
    public void Configure(EntityTypeBuilder<VendorBill> builder)
    {
        builder.ToTable("VendorBills", "AccountsPayable");
        
        builder.HasKey(x => x.Id);
        builder.Property(x => x.Id).ValueGeneratedNever();
        
        // Tenant isolation
        builder.Property(x => x.TenantId).IsRequired();
        builder.HasIndex(x => x.TenantId);
        
        // Basic properties
        builder.Property(x => x.VendorId).IsRequired();
        builder.Property(x => x.InvoiceNumber).HasMaxLength(50).IsRequired();
        builder.Property(x => x.InvoiceDate).IsRequired();
        builder.Property(x => x.DueDate).IsRequired();
        builder.Property(x => x.DocumentPath).HasMaxLength(500);
        builder.Property(x => x.Notes).HasMaxLength(1000);
        
        // Enums
        builder.Property(x => x.ApprovalStatus)
            .HasConversion<string>()
            .HasMaxLength(20);
        builder.Property(x => x.PaymentStatus)
            .HasConversion<string>()
            .HasMaxLength(20);
        
        // Money value objects
        builder.OwnsOne(x => x.TotalAmount, money =>
        {
            money.Property(m => m.Amount)
                .HasColumnName("TotalAmount")
                .HasPrecision(18, 2)
                .IsRequired();
            money.Property(m => m.Currency)
                .HasColumnName("Currency")
                .HasMaxLength(3)
                .IsRequired();
        });
        
        builder.OwnsOne(x => x.RemainingBalance, money =>
        {
            money.Property(m => m.Amount)
                .HasColumnName("RemainingBalance")
                .HasPrecision(18, 2)
                .IsRequired();
            money.Property(m => m.Currency)
                .HasColumnName("RemainingCurrency")
                .HasMaxLength(3)
                .IsRequired();
        });
        
        // Line items as owned entities
        builder.OwnsMany(x => x.LineItems, lineItem =>
        {
            lineItem.ToTable("VendorBillLineItems", "AccountsPayable");
            lineItem.Property(li => li.Description).HasMaxLength(200).IsRequired();
            lineItem.Property(li => li.Quantity).HasPrecision(10, 4).IsRequired();
            lineItem.Property(li => li.AccountCode).HasMaxLength(20);
            lineItem.Property(li => li.TaxCode).HasMaxLength(10);
            lineItem.Property(li => li.ProjectCode).HasMaxLength(20);
            
            lineItem.OwnsOne(li => li.UnitPrice, price =>
            {
                price.Property(p => p.Amount).HasColumnName("UnitPrice").HasPrecision(18, 4);
                price.Property(p => p.Currency).HasColumnName("UnitPriceCurrency").HasMaxLength(3);
            });
        });
        
        // Optimistic concurrency
        builder.Property<byte[]>("RowVersion")
            .IsRowVersion()
            .HasColumnName("RowVersion");
        
        // Indexes for performance
        builder.HasIndex(x => new { x.TenantId, x.VendorId, x.InvoiceNumber })
            .IsUnique()
            .HasDatabaseName("IX_VendorBills_TenantVendorInvoice");
        builder.HasIndex(x => new { x.TenantId, x.ApprovalStatus })
            .HasDatabaseName("IX_VendorBills_TenantApprovalStatus");
        builder.HasIndex(x => new { x.TenantId, x.DueDate })
            .HasDatabaseName("IX_VendorBills_TenantDueDate");
        builder.HasIndex(x => new { x.TenantId, x.PaymentStatus })
            .HasDatabaseName("IX_VendorBills_TenantPaymentStatus");
    }
}
```

### Repository Implementation
```csharp
public class VendorBillRepository : IVendorBillRepository
{
    private readonly AccountsPayableDbContext _context;
    private readonly ILogger<VendorBillRepository> _logger;
    
    public VendorBillRepository(AccountsPayableDbContext context, ILogger<VendorBillRepository> logger)
    {
        _context = context;
        _logger = logger;
    }
    
    public async Task<VendorBill?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.VendorBills
            .Include(vb => vb.LineItems)
            .FirstOrDefaultAsync(vb => vb.Id == id, cancellationToken);
    }
    
    public async Task<VendorBill?> GetByInvoiceNumberAsync(string invoiceNumber, Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default)
    {
        return await _context.VendorBills
            .Include(vb => vb.LineItems)
            .FirstOrDefaultAsync(vb => 
                vb.InvoiceNumber == invoiceNumber && 
                vb.VendorId == vendorId && 
                vb.TenantId == tenantId, cancellationToken);
    }
    
    public async Task<IReadOnlyList<VendorBill>> GetPendingApprovalAsync(Guid tenantId, CancellationToken cancellationToken = default)
    {
        return await _context.VendorBills
            .Where(vb => vb.TenantId == tenantId && vb.ApprovalStatus == ApprovalStatus.Pending)
            .OrderBy(vb => vb.InvoiceDate)
            .ToListAsync(cancellationToken);
    }
    
    public async Task<IReadOnlyList<VendorBill>> GetReadyForPaymentAsync(DateTime dueDate, Guid tenantId, CancellationToken cancellationToken = default)
    {
        return await _context.VendorBills
            .Where(vb => 
                vb.TenantId == tenantId &&
                vb.ApprovalStatus == ApprovalStatus.Approved &&
                vb.PaymentStatus != PaymentStatus.FullyPaid &&
                vb.DueDate <= dueDate)
            .OrderBy(vb => vb.DueDate)
            .ToListAsync(cancellationToken);
    }
    
    public async Task<bool> ExistsAsync(string invoiceNumber, Guid vendorId, Guid tenantId, CancellationToken cancellationToken = default)
    {
        return await _context.VendorBills
            .AnyAsync(vb => 
                vb.InvoiceNumber == invoiceNumber && 
                vb.VendorId == vendorId && 
                vb.TenantId == tenantId, cancellationToken);
    }
    
    public async Task SaveAsync(VendorBill vendorBill, CancellationToken cancellationToken = default)
    {
        try
        {
            if (_context.Entry(vendorBill).State == EntityState.Detached)
            {
                _context.VendorBills.Add(vendorBill);
            }
            
            await _context.SaveChangesAsync(cancellationToken);
            _logger.LogDebug("Saved vendor bill {VendorBillId}", vendorBill.Id);
        }
        catch (DbUpdateConcurrencyException ex)
        {
            _logger.LogWarning(ex, "Concurrency conflict while saving vendor bill {VendorBillId}", vendorBill.Id);
            throw new ConcurrencyException("The vendor bill was modified by another user. Please refresh and try again.");
        }
    }
}
```

### API Controllers
```csharp
[ApiController]
[Route("api/v1/accounts-payable/vendor-bills")]
[Authorize(Roles = "AP_CLERK,AP_SPECIALIST,AP_MANAGER")]
public class VendorBillsController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<VendorBillsController> _logger;
    
    public VendorBillsController(IMediator mediator, ILogger<VendorBillsController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }
    
    [HttpPost]
    [ProducesResponseType(typeof(CreateVendorBillResponse), StatusCodes.Status201Created)]
    [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status409Conflict)]
    public async Task<IActionResult> CreateVendorBill(
        [FromBody] CreateVendorBillRequest request, 
        CancellationToken cancellationToken)
    {
        try
        {
            var command = new EnterVendorBillCommand(
                request.TenantId,
                request.VendorId,
                request.InvoiceNumber,
                request.InvoiceDate,
                request.DueDate,
                request.LineItems,
                request.DocumentPath,
                request.Notes,
                request.PurchaseOrderId);
                
            var vendorBillId = await _mediator.Send(command, cancellationToken);
            
            var response = new CreateVendorBillResponse(vendorBillId);
            return CreatedAtRoute("GetVendorBill", new { id = vendorBillId }, response);
        }
        catch (DuplicateInvoiceException ex)
        {
            return Conflict(new { Message = ex.Message, ErrorCode = "DUPLICATE_INVOICE" });
        }
        catch (BusinessRuleViolationException ex)
        {
            return BadRequest(new { Message = ex.Message, ErrorCode = "BUSINESS_RULE_VIOLATION" });
        }
    }
    
    [HttpGet("{id:guid}", Name = "GetVendorBill")]
    [ProducesResponseType(typeof(VendorBillDetailResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> GetVendorBill(Guid id, CancellationToken cancellationToken)
    {
        var query = new GetVendorBillQuery(id);
        var result = await _mediator.Send(query, cancellationToken);
        
        return result != null 
            ? Ok(result) 
            : NotFound();
    }
    
    [HttpPut("{id:guid}/approve")]
    [Authorize(Roles = "AP_SPECIALIST,AP_MANAGER")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> ApproveVendorBill(
        Guid id, 
        [FromBody] ApproveVendorBillRequest request, 
        CancellationToken cancellationToken)
    {
        try
        {
            var command = new ApproveVendorBillCommand(
                request.TenantId, 
                id, 
                request.ApproverId, 
                request.Notes, 
                request.ApprovalDate);
                
            await _mediator.Send(command, cancellationToken);
            return NoContent();
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { Message = ex.Message });
        }
        catch (EntityNotFoundException)
        {
            return NotFound();
        }
    }
    
    [HttpGet]
    [ProducesResponseType(typeof(PagedResult<VendorBillSummaryReadModel>), StatusCodes.Status200OK)]
    public async Task<IActionResult> GetVendorBills(
        [FromQuery] GetVendorBillsQuery query, 
        CancellationToken cancellationToken)
    {
        var result = await _mediator.Send(query, cancellationToken);
        return Ok(result);
    }
}

[ApiController]
[Route("api/v1/accounts-payable/payment-runs")]
[Authorize(Roles = "AP_MANAGER")]
public class PaymentRunsController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<PaymentRunsController> _logger;
    
    public PaymentRunsController(IMediator mediator, ILogger<PaymentRunsController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }
    
    [HttpPost]
    [ProducesResponseType(typeof(CreatePaymentRunResponse), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<IActionResult> CreatePaymentRun(
        [FromBody] CreatePaymentRunRequest request, 
        CancellationToken cancellationToken)
    {
        try
        {
            var command = new SchedulePaymentRunCommand(
                request.TenantId,
                request.PaymentDate,
                request.VendorBillIds,
                request.PaymentMethod,
                request.Notes);
                
            var paymentRunId = await _mediator.Send(command, cancellationToken);
            
            var response = new CreatePaymentRunResponse(paymentRunId);
            return CreatedAtRoute("GetPaymentRun", new { id = paymentRunId }, response);
        }
        catch (InsufficientFundsException ex)
        {
            return BadRequest(new { Message = ex.Message, ErrorCode = "INSUFFICIENT_FUNDS" });
        }
    }
    
    [HttpGet("{id:guid}", Name = "GetPaymentRun")]
    [ProducesResponseType(typeof(PaymentRunDetailResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> GetPaymentRun(Guid id, CancellationToken cancellationToken)
    {
        var query = new GetPaymentRunQuery(id);
        var result = await _mediator.Send(query, cancellationToken);
        
        return result != null 
            ? Ok(result) 
            : NotFound();
    }
}
```

### Background Services
```csharp
[HostedService]
public class PaymentRunExecutionService : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<PaymentRunExecutionService> _logger;
    private readonly PaymentExecutionOptions _options;
    
    public PaymentRunExecutionService(
        IServiceProvider serviceProvider,
        IOptions<PaymentExecutionOptions> options,
        ILogger<PaymentRunExecutionService> logger)
    {
        _serviceProvider = serviceProvider;
        _options = options.Value;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Payment Run Execution Service started");
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await ProcessScheduledPaymentRuns(stoppingToken);
                await Task.Delay(_options.CheckInterval, stoppingToken);
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("Payment Run Execution Service is stopping");
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing payment runs");
                await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
            }
        }
    }
    
    private async Task ProcessScheduledPaymentRuns(CancellationToken cancellationToken)
    {
        using var scope = _serviceProvider.CreateScope();
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();
        var repository = scope.ServiceProvider.GetRequiredService<IPaymentRunRepository>();
        
        var scheduledRuns = await repository.GetScheduledRunsAsync(DateTime.Today, cancellationToken);
        
        foreach (var run in scheduledRuns)
        {
            try
            {
                _logger.LogInformation("Executing payment run {PaymentRunId}", run.Id);
                
                var command = new ExecutePaymentRunCommand(run.Id);
                await mediator.Send(command, cancellationToken);
                
                _logger.LogInformation("Payment run {PaymentRunId} executed successfully", run.Id);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to execute payment run {PaymentRunId}", run.Id);
            }
        }
    }
}
```

### Testing Examples

#### Unit Tests
```csharp
[TestFixture]
public class VendorBillTests
{
    private VendorBillTestBuilder _builder = null!;
    
    [SetUp]
    public void Setup()
    {
        _builder = new VendorBillTestBuilder();
    }
    
    [Test]
    public void Create_WithValidData_ShouldCreateBillSuccessfully()
    {
        // Arrange
        var tenantId = Guid.NewGuid();
        var vendorId = Guid.NewGuid();
        var lineItems = new List<BillLineItem>
        {
            new("Office supplies", 2m, new Money(50m, "USD"), "6000", "TAX1")
        };
        
        // Act
        var bill = VendorBill.Create(
            tenantId, vendorId, "INV-001", DateTime.Today.AddDays(-1), 
            DateTime.Today.AddDays(30), lineItems);
        
        // Assert
        bill.TenantId.Should().Be(tenantId);
        bill.VendorId.Should().Be(vendorId);
        bill.InvoiceNumber.Should().Be("INV-001");
        bill.TotalAmount.Should().Be(new Money(100m, "USD"));
        bill.RemainingBalance.Should().Be(new Money(100m, "USD"));
        bill.ApprovalStatus.Should().Be(ApprovalStatus.Pending);
        bill.PaymentStatus.Should().Be(PaymentStatus.Unpaid);
        bill.DomainEvents.Should().ContainSingle(e => e is VendorBillCreatedEvent);
    }
    
    [Test]
    public void Approve_WhenStatusIsPending_ShouldApproveSuccessfully()
    {
        // Arrange
        var bill = _builder
            .WithStatus(ApprovalStatus.Pending)
            .Build();
        var approverId = Guid.NewGuid();
        
        // Act
        bill.Approve(approverId, "Approved by manager");
        
        // Assert
        bill.ApprovalStatus.Should().Be(ApprovalStatus.Approved);
        bill.DomainEvents.Should().ContainSingle(e => e is VendorBillApprovedEvent approvedEvent 
            && approvedEvent.ApproverId == approverId
            && approvedEvent.Notes == "Approved by manager");
    }
    
    [Test]
    public void Approve_WhenStatusIsNotPending_ShouldThrowException()
    {
        // Arrange
        var bill = _builder
            .WithStatus(ApprovalStatus.Approved)
            .Build();
        
        // Act & Assert
        bill.Invoking(b => b.Approve(Guid.NewGuid()))
            .Should().Throw<InvalidOperationException>()
            .WithMessage("Cannot approve bill in status Approved");
    }
    
    [Test]
    public void ApplyPayment_WithValidAmount_ShouldUpdateBalanceAndStatus()
    {
        // Arrange
        var bill = _builder
            .WithTotalAmount(new Money(1000m, "USD"))
            .Build();
        var paymentAmount = new Money(300m, "USD");
        
        // Act
        bill.ApplyPayment(paymentAmount);
        
        // Assert
        bill.RemainingBalance.Should().Be(new Money(700m, "USD"));
        bill.PaymentStatus.Should().Be(PaymentStatus.PartiallyPaid);
        bill.DomainEvents.Should().ContainSingle(e => e is PaymentAppliedEvent paymentEvent 
            && paymentEvent.PaymentAmount == paymentAmount);
    }
    
    [Test]
    public void ApplyPayment_WhenCurrencyMismatch_ShouldThrowException()
    {
        // Arrange
        var bill = _builder
            .WithTotalAmount(new Money(1000m, "USD"))
            .Build();
        var paymentAmount = new Money(300m, "EUR");
        
        // Act & Assert
        bill.Invoking(b => b.ApplyPayment(paymentAmount))
            .Should().Throw<InvalidOperationException>()
            .WithMessage("Payment currency must match bill currency");
    }
}

[TestFixture]
public class EnterVendorBillCommandHandlerTests
{
    private Mock<IVendorBillRepository> _repositoryMock = null!;
    private Mock<IDuplicateDetectionService> _duplicateServiceMock = null!;
    private Mock<IThreeWayMatchingService> _matchingServiceMock = null!;
    private Mock<ILogger<EnterVendorBillCommandHandler>> _loggerMock = null!;
    private EnterVendorBillCommandHandler _handler = null!;
    
    [SetUp]
    public void Setup()
    {
        _repositoryMock = new Mock<IVendorBillRepository>();
        _duplicateServiceMock = new Mock<IDuplicateDetectionService>();
        _matchingServiceMock = new Mock<IThreeWayMatchingService>();
        _loggerMock = new Mock<ILogger<EnterVendorBillCommandHandler>>();
        
        _handler = new EnterVendorBillCommandHandler(
            _repositoryMock.Object,
            _duplicateServiceMock.Object,
            _matchingServiceMock.Object,
            _loggerMock.Object);
    }
    
    [Test]
    public async Task Handle_WithValidCommand_ShouldCreateBillAndReturnId()
    {
        // Arrange
        var command = new EnterVendorBillCommandBuilder().Build();
        _duplicateServiceMock
            .Setup(x => x.IsDuplicateAsync(command.InvoiceNumber, command.VendorId, command.TenantId, It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        
        // Act
        var result = await _handler.HandleAsync(command);
        
        // Assert
        result.Should().NotBeEmpty();
        _repositoryMock.Verify(r => r.SaveAsync(It.IsAny<VendorBill>(), It.IsAny<CancellationToken>()), Times.Once);
    }
    
    [Test]
    public async Task Handle_WhenDuplicateExists_ShouldThrowException()
    {
        // Arrange
        var command = new EnterVendorBillCommandBuilder().Build();
        _duplicateServiceMock
            .Setup(x => x.IsDuplicateAsync(command.InvoiceNumber, command.VendorId, command.TenantId, It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        
        // Act & Assert
        await _handler.Invoking(h => h.HandleAsync(command))
            .Should().ThrowAsync<DuplicateInvoiceException>()
            .WithMessage($"Invoice {command.InvoiceNumber} already exists for vendor {command.VendorId}");
        
        _repositoryMock.Verify(r => r.SaveAsync(It.IsAny<VendorBill>(), It.IsAny<CancellationToken>()), Times.Never);
    }
}
```

#### Integration Tests
```csharp
[TestFixture]
public class VendorBillRepositoryTests : DatabaseIntegrationTestBase
{
    private VendorBillRepository _repository = null!;
    private Guid _tenantId;
    private Guid _vendorId;
    
    [SetUp]
    public async Task Setup()
    {
        _repository = new VendorBillRepository(DbContext, Mock.Of<ILogger<VendorBillRepository>>());
        _tenantId = Guid.NewGuid();
        _vendorId = Guid.NewGuid();
        
        await SeedTestDataAsync();
    }
    
    [Test]
    public async Task SaveAsync_WithNewBill_ShouldPersistToDatabase()
    {
        // Arrange
        var bill = new VendorBillTestBuilder()
            .WithTenantId(_tenantId)
            .WithVendorId(_vendorId)
            .WithInvoiceNumber("TEST-001")
            .Build();
        
        // Act
        await _repository.SaveAsync(bill);
        
        // Assert
        var savedBill = await _repository.GetByIdAsync(bill.Id);
        savedBill.Should().NotBeNull();
        savedBill!.InvoiceNumber.Should().Be("TEST-001");
        savedBill.LineItems.Should().HaveCount(bill.LineItems.Count);
    }
    
    [Test]
    public async Task GetByInvoiceNumberAsync_WhenExists_ShouldReturnBill()
    {
        // Arrange
        var existingBill = await CreateTestBillAsync("EXISTING-001");
        
        // Act
        var result = await _repository.GetByInvoiceNumberAsync("EXISTING-001", _vendorId, _tenantId);
        
        // Assert
        result.Should().NotBeNull();
        result!.Id.Should().Be(existingBill.Id);
    }
    
    [Test]
    public async Task GetPendingApprovalAsync_ShouldReturnOnlyPendingBills()
    {
        // Arrange
        await CreateTestBillAsync("PENDING-001", ApprovalStatus.Pending);
        await CreateTestBillAsync("APPROVED-001", ApprovalStatus.Approved);
        await CreateTestBillAsync("REJECTED-001", ApprovalStatus.Rejected);
        
        // Act
        var result = await _repository.GetPendingApprovalAsync(_tenantId);
        
        // Assert
        result.Should().HaveCount(1);
        result.Single().InvoiceNumber.Should().Be("PENDING-001");
    }
    
    private async Task<VendorBill> CreateTestBillAsync(string invoiceNumber, ApprovalStatus status = ApprovalStatus.Pending)
    {
        var bill = new VendorBillTestBuilder()
            .WithTenantId(_tenantId)
            .WithVendorId(_vendorId)
            .WithInvoiceNumber(invoiceNumber)
            .WithStatus(status)
            .Build();
            
        await _repository.SaveAsync(bill);
        return bill;
    }
}
```

---

## Quality Gates & TDD Checklist

### ✅ Domain Model Validation
- [ ] All aggregates have proper invariant enforcement
- [ ] Value objects are immutable and contain validation logic
- [ ] Domain events are raised at appropriate boundaries
- [ ] Business rules are encoded in domain objects, not services

### ✅ Command/Query Separation
- [ ] Commands return only success/failure indicators
- [ ] Queries never modify state
- [ ] Read models are optimized for specific UI scenarios
- [ ] Command handlers contain minimal logic (orchestration only)

### ✅ Multi-tenancy & Security
- [ ] All entities include TenantId for data isolation
- [ ] Repository queries automatically filter by tenant
- [ ] API endpoints enforce role-based authorization
- [ ] Sensitive data is properly encrypted/masked

### ✅ Performance & Scalability
- [ ] Database indexes align with query patterns
- [ ] Repository methods use efficient LINQ queries
- [ ] Read models are properly denormalized
- [ ] Background services handle long-running operations

### ✅ Reliability & Error Handling
- [ ] Optimistic concurrency conflicts are handled gracefully
- [ ] Retry policies are implemented for external service calls
- [ ] Circuit breakers prevent cascade failures
- [ ] Compensation logic handles partial failure scenarios

### ✅ Observability & Monitoring
- [ ] Structured logging with correlation IDs
- [ ] Key metrics are tracked (payment success rates, processing times)
- [ ] Health checks monitor critical dependencies
- [ ] Distributed tracing spans cross-service calls

---

## Solution Layout (Visual Studio 2022)
```
📁 AHS.FinTechBook.sln
│
├── 📁 src
│   ├── 📁 Common
│   │   ├── Common.Domain (Shared kernel, base classes)
│   │   ├── Common.Application (CQRS infrastructure, behaviors)
│   │   ├── Common.Infrastructure (EF Core, messaging, caching)
│   │   └── Common.Tests (Shared test utilities)
│   │
│   ├── 📁 BoundedContexts
│   │   └── 📁 AccountsPayable
│   │       ├── 📁 Domain
│   │       │   ├── Aggregates (VendorBill, PaymentRun, VendorCredit)
│   │       │   ├── ValueObjects (Money, BillLineItem, etc.)
│   │       │   ├── Services (IDuplicateDetectionService, etc.)
│   │       │   ├── Events (Domain events)
│   │       │   └── Repositories (Repository contracts)
│   │       │
│   │       ├── 📁 Application
│   │       │   ├── Commands (Command DTOs and handlers)
│   │       │   ├── Queries (Query DTOs and handlers)
│   │       │   ├── Handlers (Command/query handlers)
│   │       │   └── ReadModels (CQRS read projections)
│   │       │
│   │       ├── 📁 Infrastructure
│   │       │   ├── Persistence (EF Core configurations, repositories)
│   │       │   ├── ACL (Anti-corruption layers)
│   │       │   ├── Messaging (Event publishing/handling)
│   │       │   └── Services (External service adapters)
│   │       │
│   │       └── 📁 Tests
│   │           ├── Unit (Fast, isolated tests)
│   │           ├── Integration (Database, external services)
│   │           └── E2E (Full workflow tests)
│   │
│   └── 📁 API
│       ├── Controllers (REST API endpoints)
│       ├── DTOs (Request/response models)
│       ├── Middleware (Authentication, logging, etc.)
│       └── Configuration (DI setup, options)
│
├── 📁 tests
│   ├── ArchitectureTests (Enforce architectural rules)
│   └── PerformanceTests (Load testing)
│
└── 📁 docs
    ├── AccountsPayable.md (This document)
    ├── API.md (API documentation)
    └── Deployment.md (Deployment guide)
```

**Key Features for Visual Studio 2022:**
- **Solution Filters** for focused development on specific bounded contexts
- **EditorConfig** for consistent code formatting
- **Directory.Build.props** for centralized package management
- **Launch profiles** for different debugging scenarios
- **Docker Compose** support for local development environment
- **Code Analysis** rules enforcing architectural constraints

---

## Open Questions (for stakeholder validation)

1. **Approval Workflow Complexity**: What are the specific approval thresholds and routing rules? Should we support parallel vs. serial approval chains?

2. **Payment Method Coverage**: Which payment methods should be supported by region/currency? Are there specific compliance requirements (PCI, ACH regulations)?

3. **General Ledger Integration**: What's the expected accounting entry structure? Should we support different chart of accounts per tenant?

4. **Three-Way Matching Tolerance**: What discrepancy thresholds should trigger manual review vs. automatic approval?

5. **Cash Flow Integration**: How should we integrate with existing treasury management systems? What forecasting accuracy is required?

6. **Audit Requirements**: What level of audit detail is needed? Should we maintain full change history or summary audit logs?

7. **Performance Requirements**: What are the expected transaction volumes? Should we implement CQRS with separate read/write databases?

8. **Multi-Currency Support**: How should we handle currency conversion and rate management? Real-time rates or daily fixes?

---

This enhanced bounded context specification provides a comprehensive foundation for implementing a robust, scalable Accounts Payable system using modern C# development practices with Visual Studio 2022. The design emphasizes domain-driven design principles, comprehensive testing strategies, and enterprise-grade quality standards.
